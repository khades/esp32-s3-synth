/* Blink Example

   This example code is in the Public Domain (or CC0 licensed, at your option.)

   Unless required by applicable law or agreed to in writing, this
   software is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
   CONDITIONS OF ANY KIND, either express or implied.
*/
#include "driver/gpio.h"
#include "driver/i2s_common.h"
#include "driver/i2s_std.h"

#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "hal/i2s_types.h"
#include "led_strip.h"
#include "sdkconfig.h"
#include <math.h>
#include <stdio.h>

static const char *TAG = "example";

#include "esp_system.h"
#include <math.h>

/* Use project configuration menu (idf.py menuconfig) to choose the GPIO to
   blink, or you can edit the following line and set a number here.
*/
#define BLINK_GPIO 48
#define CONFIG_BLINK_PERIOD 1000

#define SAMPLE_RATE (48000)
#define AUDIO_BITS I2S_DATA_BIT_WIDTH_32BIT
#define AUDIO_CHANNELS I2S_SLOT_MODE_STEREO

#define BITS_PER_SEC (SAMPLE_RATE * AUDIO_BITS * AUDIO_CHANNELS)
#define BYTES_PER_10MS (SAMPLE_RATE / 800)

static uint8_t s_led_state = 0;

static led_strip_handle_t led_strip;

static void blink_led(void) {
  /* If the addressable LED is enabled */
  if (s_led_state > 0) {
    /* Set the LED pixel using RGB from 0 (0%) to 255 (100%) for each color */
    switch (s_led_state) {
    case 1:
      led_strip_set_pixel(led_strip, 0, 1, 0, 0);
      break;
    case 2:
      led_strip_set_pixel(led_strip, 0, 0, 1, 0);
      break;
    case 3:
      led_strip_set_pixel(led_strip, 0, 0, 0, 1);
      break;
    }
    /* Refresh the strip to send data */
    led_strip_refresh(led_strip);
  } else {
    /* Set all LED off to clear all pixels */
    led_strip_clear(led_strip);
  }

  if (s_led_state == 3) {
    s_led_state = 0;
  } else {
    s_led_state = s_led_state + 1;
  }
}

static void configure_led(void) {
  ESP_LOGI(TAG, "Example configured to blink addressable LED!");
  /* LED strip initialization with the GPIO and pixels number*/
  led_strip_config_t strip_config = {
      .strip_gpio_num = BLINK_GPIO,
      .max_leds = 1, // at least one LED on board
  };
  led_strip_rmt_config_t rmt_config = {
      .resolution_hz = 10 * 1000 * 1000, // 10MHz
      .flags.with_dma = false,
  };
  ESP_ERROR_CHECK(
      led_strip_new_rmt_device(&strip_config, &rmt_config, &led_strip));

  /* Set all LED off to clear all pixels */
  led_strip_clear(led_strip);
}

#define I2S_LRC 11
#define I2S_BCLK 13
#define I2S_DOUT 12
#define I2S_MCLK 10 /* Master clock */

i2s_chan_handle_t tx_handle;

/* Get the default channel configuration by the helper macro.
 * This helper macro is defined in `i2s_common.h` and shared by all the I2S
 * communication modes. It can help to specify the I2S role and port ID */
i2s_chan_config_t chan_cfg =
    I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_AUTO, I2S_ROLE_MASTER);
/* Allocate a new TX channel and get the handle of this channel */

/* Setting the configurations, the slot configuration and clock configuration
 * can be generated by the macros These two helper macros are defined in
 * `i2s_std.h` which can only be used in STD mode. They can help to specify the
 * slot and clock configurations for initialization or updating */
i2s_std_config_t std_cfg = {
    .clk_cfg = I2S_STD_CLK_DEFAULT_CONFIG(SAMPLE_RATE),
    .slot_cfg =
        I2S_STD_MSB_SLOT_DEFAULT_CONFIG(AUDIO_BITS, I2S_SLOT_MODE_STEREO),
    .gpio_cfg =
        {
            .mclk = I2S_MCLK,
            .bclk = I2S_BCLK,
            .ws = I2S_LRC,
            .dout = I2S_DOUT,
            .din = I2S_GPIO_UNUSED,
            .invert_flags =
                {
                    .mclk_inv = false,
                    .bclk_inv = false,
                    .ws_inv = false,
                },
        },
};

void app_main(void) {

  configure_led();

  i2s_new_channel(&chan_cfg, &tx_handle, NULL);

  i2s_channel_init_std_mode(tx_handle, &std_cfg);

  /* Before writing data, start the TX channel first */
  // i2s_channel_enable(tx_handle);

  uint8_t *w_buf = (uint8_t *)calloc(1, BYTES_PER_10MS);
  assert(w_buf); // Check if w_buf allocation success

  /* Assign w_buf */
  for (int i = 0; i < BYTES_PER_10MS; i += 8) {
    w_buf[i] = 0x12;
    w_buf[i + 1] = 0x34;
    w_buf[i + 2] = 0x56;
    w_buf[i + 3] = 0x78;
    w_buf[i + 4] = 0x9A;
    w_buf[i + 5] = 0xBC;
    w_buf[i + 6] = 0xDE;
    w_buf[i + 7] = 0xF0;
  }

  size_t w_bytes = BYTES_PER_10MS;

  /* (Optional) Preload the data before enabling the TX channel, so that the
   * valid data can be transmitted immediately */
  while (w_bytes == BYTES_PER_10MS) {
    /* Here we load the target buffer repeatedly, until all the DMA buffers are
     * preloaded */
    ESP_ERROR_CHECK(
        i2s_channel_preload_data(tx_handle, w_buf, BYTES_PER_10MS, &w_bytes));
  }

  /* Enable the TX channel */
  ESP_ERROR_CHECK(i2s_channel_enable(tx_handle));
  while (1) {
    // i2s_channel_register_event_callback(i2s_chan_handle_t handle, const
    // i2s_event_callbacks_t *callbacks, void *user_data)
    /* Write i2s data */
    if (i2s_channel_write(tx_handle, w_buf, BYTES_PER_10MS, &w_bytes, 1000) ==
        ESP_OK) {
      printf("Write Task: i2s write %d bytes\n", w_bytes);
    } else {
      printf("Write Task: i2s write failed\n");
    }
    ESP_LOGI(TAG, "Turning the LED %s!", s_led_state == true ? "ON" : "OFF");
    blink_led();
    vTaskDelay(10);
  }
  free(w_buf);

  // while (1) {

  //   /* Toggle the LED state */
  //   vTaskDelay(CONFIG_BLINK_PERIOD / portTICK_PERIOD_MS);
  // }
}